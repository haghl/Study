# 캐시 최적화 하기

## 목차

### 1. 웹 캐시 동작원리

### 2. 캐시 최적화 방안

### 3. 고급 캐시 전략



## 1. 웹 캐시 동작원리

웹 캐시는 웹 서버와 웹 브라우저 중간에 위치하며 최초 원본 콘텐츠 요청을 최종 서버에 보내 응답을 받은 후 그 복사본을 만들어 저장하고 사용자에게 응답합니다.

이후 같은 콘텐츠에 대한 요청이 오면 저장한 복사본을 사용자에게 전달하여 원본 서버로의 트래픽을 줄이고 사용자의 요청에 대한 반응 속도를 빠르게 합니다.

![cache](https://user-images.githubusercontent.com/66556683/145521902-7f52e4a7-26e4-46e2-b832-73d15b462de3.jpg)

#### 1) HTTP의 캐시 제어 방식

캐시는 HTTP/1.1부터 명시적으로 캐시를 제어할 수 있는 Cache-Control 헤더가 추가됩니다.

HTTP/1.1에서 캐시를 제어하는 목적

- 원본 서버로의 요청 수를 최소화합니다. (네트워크 왕복 수를 줄여 결과적으로 사용자 요청에 대한 응답 속도를 단축할 수 있습니다.)
- 완전한 콘텐츠를 응답하지 않아도 됩니다. (네트워크 대역폭과 리소스 낭비를 줄이고 비용을 효율화합니다.)



**Expire**  

HTTP/1.0에서는 Expire 헤더를 사용하여 원본 서버 콘텐츠의 유효 기간을 지정하도록 정의합니다. Expire 헤더는 캐시를 명시적으로 제어하지는 않지만 브라우저를 포함한 대부분의 캐시 서버에서 콘텐츠를 언제까지 저장할 것인지 판단하기 위해 사용합니다.

원본 서버는 Expire와 Date 헤더를 함께 보내야 하며 Date 헤더는 요청에 대한 응답이 작성된 시점을 표시합니다. 캐시는 간단히 Expire 날짜에서 Date 날짜를 빼는 것으로 해당 응답의 **캐시 유지 시간(TTL : Time To Live)** 을 결정할 수 있습니다. 두 헤더는 모두 원본 서버 시간을 기준으로 생성되는 값이므로 원본 서버는 정확한 시계를 사용해 값을 생성해야 합니다.

```
Time To Live (TTL) = Expire_value - Date_value
```



**Cache-Control : max-age**

Cache-Control : max-age라는 헤더는 콘텐츠의 캐시 유지 시간을 정의합니다. 원본 서버는 이 헤더를 사용해 캐시에서 특정 콘텐츠를 얼마나 오래 유지하고 있어야 하는지 명시적으로 설정합니다. (초 단위로 설정 예를 들어 1년은 31536000초)

![max-age](https://user-images.githubusercontent.com/66556683/145530380-e57f864d-8158-4300-ac16-de7d7530097a.png)

Expire과 Cache-Control : max-age 헤더는 원본 서버 콘텐츠의 캐시 TTL을 결정하는 동일한 용도로 사용합니다. 그러나 HTTP/1.0 기반의 캐시 서버나 브라우저가 Cache-Control : max-age 를 지원하지 않기 때문에 원본 서버는 모든 응답에  두 헤더의 값을 모두 표시해야 합니다. HTTP/1.1을 지원하는 캐시 서버는 두 헤더가 모두 명시된 경우 Cache-Control을 우선으로 사용합니다.

동작 순서

1. 첫 번째 요청에 대해 캐시된 응답이 없으므로 캐시 서버에서는 원본 서버에 그대로 요청을 전송합니다.
2. 첫 번째 요청에 대해 원본 서버에서  응답을 생성하고 해당 객체가 언제까지 유효한지를 HTTP 헤더에 명시합니다.
3. 캐시 서버는 해당 요청에 대한 캐시 키와 함께 응답을 저장하고 만료일을 설정한 후 요청자에게 응답을 전송합니다.
4. 이후 같은 요청을 한 시점이 만료일을 지나지 않았다면 캐시에 저장된 응답을 사용자에게 전송합니다.

![caching](https://user-images.githubusercontent.com/66556683/145533114-abff60b6-dbd5-47d6-96a0-836d60b772d4.gif)



**ETag**

ETag(Entity Tag) 헤더는 원본 서버가 리소스를 식별하기 위해 부여하는 고유 번호입니다. ETag가 어떤 조합이 될지는 전적으로 원본 서버가 결정합니다. 캐시 서버에서는 ETag를 사용해 원본 서버의 리소스가 시간이 지나 만료되었는지, 캐시된 리소스를 새로 갱신해야 하는지 여부를 명확히 판단할 수 있습니다.

![etag](https://user-images.githubusercontent.com/66556683/145535514-71d916da-570a-45ca-9ecc-d295a16a394b.jpg)

ETag는 크게 Strong ETag와 Weak ETag 두 가지로 구분합니다.

Strong ETag는 모든 리소스에 대해 유일한 값을 가져야 하기 때문에 Weak ETag에 비해 값을 생성하는 과정이 까다롭습니다.

그에 비해 Weak ETag 비교적 간단히 값을 생성할 수 있지만 ETag에 대한 신뢰도가 약해집니다. ETag의 역할이 중요하지 않으면 할당할 수 있습니다.

이 때 'w/'를 붙여 이 값이 유일하지 않을 수 있지만 괜찮다라는 메시지를 캐시 서버에 전달해야 합니다.

```
ETag: W/"0815"
```



**Cache-Control: public/private**

public으로 설정하면 그 응답은 모든 캐시 서버에 캐시될 수 있고 사용자 제한 없이 모든 사용자에게 응답이 전달될 수 있습니다.

private으로 설정하면 HTTP 요청에 대한 응답은 요청한 사용자만 캐시할 수 있고 CDN같은 범용 캐시 서버에서는 캐시할 수 없습니다. private는 원본 서버가 일부 응답을 특정 사용자에게만 전달하는데 목적이 있으므로 캐시 콘텐츠가 공유되면 안 됩니다. 하지만 private을 설정한다고 해서 응답에 담긴 개인 정보까지 보호되지는 않으니 주의해야 합니다.



**Cache-Control: no-cache/no-store**

no-cache는 요청과 응답 헤더에 모두 사용할 수 있습니다. 요청에 있으면 캐시 서버는 항상 원본 서버에서 최신 응답을 받아와야 합니다.

이 헤더가 응답에 있으면 원본 서버가 캐시 서버들에게 캐시된 응답을 보내기 전 원본 서버를 항상 확인하도록 강제합니다.

no-store 또한 요청과 응답 헤더에 모두 사용할 수 있습니다. no-store은 서버가 로컬 저장소에 메시지를 저장하지 않도록 지시하여 캐시 데이터의 예기치 않은 유출을 방지하려는 것입니다.

하지만 no-store은 개인 정보 보호 수준이 조금 향상될 수 있지만 완벽한 보안 메커니즘으로 신뢰하기 어렵기 때문에 보안 기능만을 목적으로 사용할 수 없습니다.



#### 2) 캐시 유효성 체크

사용자가 특정 웹 콘텐츠에 대한 요청을 캐시로 보냈을 때 캐시에 저장되어 있는 응답의 age가 max-age 값을 넘었다면 그 응답은 더 이상 신뢰할 수 없습니다. 그러므로 원본 서버에서 요청을 보내 새 응답을 받아와야 합니다. 하지만 해당 콘텐츠의 아무런 변화가 없었다면 원본 서버는 의미 없는 응답을 만들어 전송하기 위해 서버 자원과 네트워크 대역폭을 낭비합니다.

이러한 비효율적인 요청과 응답을 방지하고자 HTTP 표준은 조건부 요청이라는 메커니즘을 정의합니다. 이 메커니즘은 저장된 응답 TTL이 만료되었을 경우 캐시가 항상 원본 서버에서 완전한 콘텐츠를 받아오는 대신 TTL 주기 동안 콘텐츠에 변화가 있을 때에만 새 응답을 만들도록 요청합니다.

![request](https://user-images.githubusercontent.com/66556683/145954614-e2c27eeb-aba3-40b6-8fbf-24823eb446f1.jpg)



조건부 요청은 시간을 기반으로 보내는 방법과 콘텐츠를 기반으로 보내는 두 가지 방법을 사용할 수 있습니다.





**시간 기반의 조건부 요청**

어떤 요청에 대한 원본 서버의 콘텐츠가 캐시에 저장된 후 변경되었는지 여부를 콘텐츠의 최종 변경 시간 중심으로 확인하는 방법입니다.

저장된 객체가 변경되어 새로 저장되면 그 날짜와 시간을 메타 데이터로 남기고 원본 서버가 콘텐츠에 대한 응답을 만들어 보낼 때 Last-Modified라는 헤더에 최종 변경 날짜와 시간을 적어 보냅니다.

캐시는 최초 요청에 대한 이 응답을 저장하고 TTL 시간이 지난 이후 같은 요청이 오면 If-Modified-Since라는 헤더에 Last-Modified의 값을 복사해 원본 서버에 전송하여 불필요한 네트워크 자원 낭비를 막을 수 있습니다.

```
Cache-control: public, max-age=31536000
Last-Modified: Sat, 26 Aug 2017 14:23:11 GMT

If-Modified-Since: Sat, 26 Aug 2017 14:23:11 GMT
```



**콘텐츠 기반의 조건부 요청**

어떤 요청에 대한 원본 서버의 콘텐츠가 캐시에 저장된 후 변경되었는지 여부를 콘텐츠의 고윳값 중심으로 확인하는 방법입니다. 고윳값은 원본 서버에서 정의하기 나름이지만 주로 해시값으로 추출합니다. 콘텐츠의 내용이 변경이 되면 해시값도 변경되기 때문에 이 값을 비교하여 콘텐츠의 변경 여부를 확인할 수 있습니다.

요청 응답 프로세스는 시간 기반의 조건부 요청과 비슷합니다. 같은 요청이 오면 If-None-Match라는 헤더에 ETag의 값을 복사해 원본 서버에 전송합니다.

```
Cache-control: public, max-age=31536000
ETag: "151511515153s5ads15535f"

If-None-Match: "151511515153s5ads15535f"
```



#### 3) 캐시 콘텐츠 갱신





## 2. 캐시 최적화 방안

## 3. 고급 캐시 전략











웹 캐시 동작원리

​	HTTP의 캐시 제어 방식

​	캐시 유효성 체크

​	캐시 콘텐츠 갱신



캐시 최적화 방안

​	캐시 가능한 콘텐츠 구분하기

​	올바른 캐시 정책 설정하기

​	캐시 주기 결정하기

​	캐시에 적합한 디렉터리 구조 구성하기

​	캐시 키 올바르게 사용하기

​	CDN 사용하기

고급 캐시 전략

​	Edge Side Include

​	HTML5 로컬 스토리지

인터넷 캐시 사용

브라우저 캐시 사용