# 캐시 최적화 하기

## 목차

### 1. 웹 캐시 동작원리

### 2. 캐시 최적화 방안

### 3. 고급 캐시 전략




## 1. 웹 캐시 동작원리

웹 캐시는 웹 서버와 웹 브라우저 중간에 위치하며 최초 원본 콘텐츠 요청을 최종 서버에 보내 응답을 받은 후 그 복사본을 만들어 저장하고 사용자에게 응답합니다.

이후 같은 콘텐츠에 대한 요청이 오면 저장한 복사본을 사용자에게 전달하여 원본 서버로의 트래픽을 줄이고 사용자의 요청에 대한 반응 속도를 빠르게 합니다.

즉 캐시의 주된 목적은 원본 서버로의 요청 수와 네트워크 대역폭 낭비를 줄여, 많은 트래픽을 처리해야 하는 원본 서버의 부담을 줄이는 것입니다.

![cache](https://user-images.githubusercontent.com/66556683/145521902-7f52e4a7-26e4-46e2-b832-73d15b462de3.jpg)

#### 1) HTTP의 캐시 제어 방식

캐시는 HTTP/1.1부터 명시적으로 캐시를 제어할 수 있는 Cache-Control 헤더가 추가됩니다.

HTTP/1.1에서 캐시를 제어하는 목적

- 원본 서버로의 요청 수를 최소화합니다. (네트워크 왕복 수를 줄여 결과적으로 사용자 요청에 대한 응답 속도를 단축할 수 있습니다.)
- 완전한 콘텐츠를 응답하지 않아도 됩니다. (네트워크 대역폭과 리소스 낭비를 줄이고 비용을 효율화합니다.)



**Expire**  

HTTP/1.0에서는 Expire 헤더를 사용하여 원본 서버 콘텐츠의 유효 기간을 지정하도록 정의합니다. Expire 헤더는 캐시를 명시적으로 제어하지는 않지만 브라우저를 포함한 대부분의 캐시 서버에서 콘텐츠를 언제까지 저장할 것인지 판단하기 위해 사용합니다.

원본 서버는 Expire와 Date 헤더를 함께 보내야 하며 Date 헤더는 요청에 대한 응답이 작성된 시점을 표시합니다. 캐시는 간단히 Expire 날짜에서 Date 날짜를 빼는 것으로 해당 응답의 **캐시 유지 시간(TTL : Time To Live)** 을 결정할 수 있습니다. 두 헤더는 모두 원본 서버 시간을 기준으로 생성되는 값이므로 원본 서버는 정확한 시계를 사용해 값을 생성해야 합니다.

```
Time To Live (TTL) = Expire_value - Date_value
```



**Cache-Control : max-age**

Cache-Control : max-age라는 헤더는 콘텐츠의 캐시 유지 시간을 정의합니다. 원본 서버는 이 헤더를 사용해 캐시에서 특정 콘텐츠를 얼마나 오래 유지하고 있어야 하는지 명시적으로 설정합니다. (초 단위로 설정 예를 들어 1년은 31536000초)

![max-age](https://user-images.githubusercontent.com/66556683/145530380-e57f864d-8158-4300-ac16-de7d7530097a.png)

Expire과 Cache-Control : max-age 헤더는 원본 서버 콘텐츠의 캐시 TTL을 결정하는 동일한 용도로 사용합니다. 그러나 HTTP/1.0 기반의 캐시 서버나 브라우저가 Cache-Control : max-age 를 지원하지 않기 때문에 원본 서버는 모든 응답에  두 헤더의 값을 모두 표시해야 합니다. HTTP/1.1을 지원하는 캐시 서버는 두 헤더가 모두 명시된 경우 Cache-Control을 우선으로 사용합니다.

동작 순서

1. 첫 번째 요청에 대해 캐시된 응답이 없으므로 캐시 서버에서는 원본 서버에 그대로 요청을 전송합니다.
2. 첫 번째 요청에 대해 원본 서버에서  응답을 생성하고 해당 객체가 언제까지 유효한지를 HTTP 헤더에 명시합니다.
3. 캐시 서버는 해당 요청에 대한 캐시 키와 함께 응답을 저장하고 만료일을 설정한 후 요청자에게 응답을 전송합니다.
4. 이후 같은 요청을 한 시점이 만료일을 지나지 않았다면 캐시에 저장된 응답을 사용자에게 전송합니다.

![caching](https://user-images.githubusercontent.com/66556683/145533114-abff60b6-dbd5-47d6-96a0-836d60b772d4.gif)

|                            네이버                            |                             구글                             |
| :----------------------------------------------------------: | :----------------------------------------------------------: |
| <img src="https://user-images.githubusercontent.com/66556683/146849255-9faeb7eb-ee19-4cc2-83f4-e2fd14f59841.png" alt="navercache1" style="zoom:150%;" /> | <img src="https://user-images.githubusercontent.com/66556683/146849843-825044da-9db7-4fa0-b879-2f3c7654297a.png" alt="googlecache1" style="zoom:150%;" /> |



**ETag**

ETag(Entity Tag) 헤더는 원본 서버가 리소스를 식별하기 위해 부여하는 고유 번호입니다. ETag가 어떤 조합이 될지는 전적으로 원본 서버가 결정합니다. 캐시 서버에서는 ETag를 사용해 원본 서버의 리소스가 시간이 지나 만료되었는지, 캐시된 리소스를 새로 갱신해야 하는지 여부를 명확히 판단할 수 있습니다.

![etag](https://user-images.githubusercontent.com/66556683/145535514-71d916da-570a-45ca-9ecc-d295a16a394b.jpg)

ETag는 크게 Strong ETag와 Weak ETag 두 가지로 구분합니다.

Strong ETag는 모든 리소스에 대해 유일한 값을 가져야 하기 때문에 Weak ETag에 비해 값을 생성하는 과정이 까다롭습니다.

그에 비해 Weak ETag 비교적 간단히 값을 생성할 수 있지만 ETag에 대한 신뢰도가 약해집니다. ETag의 역할이 중요하지 않으면 할당할 수 있습니다.

이 때 'w/'를 붙여 이 값이 유일하지 않을 수 있지만 괜찮다라는 메시지를 캐시 서버에 전달해야 합니다.

```
ETag: W/"0815"
```

| <img src="https://user-images.githubusercontent.com/66556683/146851794-bace98ae-1ca1-40a3-8dfa-8d7adca210b0.png" alt="navercache2" style="zoom:150%;" /> | <img src="https://user-images.githubusercontent.com/66556683/146851797-6a361ae2-be52-465f-a6f5-274d401f3293.png" alt="navercache3" style="zoom:150%;" /> |
| :----------------------------------------------------------: | :----------------------------------------------------------: |

**Cache-Control: public/private**

public으로 설정하면 그 응답은 모든 캐시 서버에 캐시될 수 있고 사용자 제한 없이 모든 사용자에게 응답이 전달될 수 있습니다.

private으로 설정하면 HTTP 요청에 대한 응답은 요청한 사용자만 캐시할 수 있고 CDN같은 범용 캐시 서버에서는 캐시할 수 없습니다. private는 원본 서버가 일부 응답을 특정 사용자에게만 전달하는데 목적이 있으므로 캐시 콘텐츠가 공유되면 안 됩니다. 하지만 private을 설정한다고 해서 응답에 담긴 개인 정보까지 보호되지는 않으니 주의해야 합니다.

public과 private은 응답 메시지를 어디에 캐시할 것인지 지정하기 위해 사용할 뿐 그 자체로 개인 정보를 보호하는 장치가 되지는 않습니다.



**Cache-Control: no-cache/no-store**

no-cache는 요청과 응답 헤더에 모두 사용할 수 있습니다. 요청에 있으면 캐시 서버는 항상 원본 서버에서 최신 응답을 받아와야 합니다.

이 헤더가 응답에 있으면 원본 서버가 캐시 서버들에게 캐시된 응답을 보내기 전 원본 서버를 항상 확인하도록 강제합니다.

no-store 또한 요청과 응답 헤더에 모두 사용할 수 있습니다. no-store은 서버가 로컬 저장소에 메시지를 저장하지 않도록 지시하여 캐시 데이터의 예기치 않은 유출을 방지하려는 것입니다.

하지만 no-store은 개인 정보 보호 수준이 조금 향상될 수 있지만 완벽한 보안 메커니즘으로 신뢰하기 어렵기 때문에 보안 기능만을 목적으로 사용할 수 없습니다.



#### 2) 캐시 유효성 체크

사용자가 특정 웹 콘텐츠에 대한 요청을 캐시로 보냈을 때 캐시에 저장되어 있는 응답의 age가 max-age 값을 넘었다면 그 응답은 더 이상 신뢰할 수 없습니다. 그러므로 원본 서버에서 요청을 보내 새 응답을 받아와야 합니다. 하지만 해당 콘텐츠의 아무런 변화가 없었다면 원본 서버는 의미 없는 응답을 만들어 전송하기 위해 서버 자원과 네트워크 대역폭을 낭비합니다.

이러한 비효율적인 요청과 응답을 방지하고자 HTTP 표준은 조건부 요청이라는 메커니즘을 정의합니다. 이 메커니즘은 저장된 응답 TTL이 만료되었을 경우 캐시가 항상 원본 서버에서 완전한 콘텐츠를 받아오는 대신 TTL 주기 동안 콘텐츠에 변화가 있을 때에만 새 응답을 만들도록 요청합니다.

![request](https://user-images.githubusercontent.com/66556683/145954614-e2c27eeb-aba3-40b6-8fbf-24823eb446f1.jpg)



조건부 요청은 시간을 기반으로 보내는 방법과 콘텐츠를 기반으로 보내는 두 가지 방법을 사용할 수 있습니다.



**시간 기반의 조건부 요청**

어떤 요청에 대한 원본 서버의 콘텐츠가 캐시에 저장된 후 변경되었는지 여부를 콘텐츠의 최종 변경 시간 중심으로 확인하는 방법입니다.

저장된 객체가 변경되어 새로 저장되면 그 날짜와 시간을 메타 데이터로 남기고 원본 서버가 콘텐츠에 대한 응답을 만들어 보낼 때 Last-Modified라는 헤더에 최종 변경 날짜와 시간을 적어 보냅니다.

캐시는 최초 요청에 대한 이 응답을 저장하고 TTL 시간이 지난 이후 같은 요청이 오면 If-Modified-Since라는 헤더에 Last-Modified의 값을 복사해 원본 서버에 전송하여 불필요한 네트워크 자원 낭비를 막을 수 있습니다.

```
Cache-control: public, max-age=31536000
Last-Modified: Sat, 26 Aug 2017 14:23:11 GMT

If-Modified-Since: Sat, 26 Aug 2017 14:23:11 GMT
```



**콘텐츠 기반의 조건부 요청**

어떤 요청에 대한 원본 서버의 콘텐츠가 캐시에 저장된 후 변경되었는지 여부를 콘텐츠의 고윳값 중심으로 확인하는 방법입니다. 고윳값은 원본 서버에서 정의하기 나름이지만 주로 해시값으로 추출합니다. 콘텐츠의 내용이 변경이 되면 해시값도 변경되기 때문에 이 값을 비교하여 콘텐츠의 변경 여부를 확인할 수 있습니다.

요청 응답 프로세스는 시간 기반의 조건부 요청과 비슷합니다. 같은 요청이 오면 If-None-Match라는 헤더에 ETag의 값을 복사해 원본 서버에 전송합니다.

```
Cache-control: public, max-age=31536000
ETag: "151511515153s5ads15535f"

If-None-Match: "151511515153s5ads15535f"
```



#### 3) 캐시 콘텐츠 갱신

웹 사이트가 개편되었거나 콘텐츠를 급하게 변경했다면 캐시에 저장된 복사본들을 강제로 갱신해야 사용자에게 정상적인 웹 페이지를 서비스할 수 있습니다.

캐시에 저장된 내용을 갱신하기 위한 방법은 2가지가 있습니다.



**퍼지(purge)**

퍼지는 저장소를 완전히 지우는 방식으로 대부분의 캐시 서버가 캐시를 모두 지우는 명령어나 API를 제공합니다. 또한 브라우저의 옵션 메뉴에서 로컬 캐시를 지울 수 있습니다.

캐시 서버에서 한꺼번에 많은 콘텐츠를 퍼지하려면 원본 서버에 충분한 자원이 있는지 확인하는 등 주의가 필요합니다. 캐시 되지 않은 많은 요청이 한꺼번에 원본 서버로 몰려 서버 리소스가 많이 사용되는 부담이 있기 때문입니다.



**무효화(invalidate)**

무효화는 캐시 저장소를 완전히 지우기 보다 조건부 요청을 통해 캐시된 리소스들 중 변경이 있었던 리소스들만 새로 갱신하는 방법입니다.

아래와 같이 Cache-Control 헤더를 사용해 캐시 서버의 내용을 강제로 무효화할 수 있습니다.

```
Cache-constrol: max-age=0, must-revalidate
```

원본 서버나 웹 캐시 서버에서 이러한 무효화 정책을 사용할 경우 퍼지와 동일하게 새 콘텐츠를 받아가려는 트래픽이 잠시 증가할 수 있습니다. 하지만 퍼지와 다르게 대부분 If-Modified-Since 나 If-None-Match 요청일 것이고 실제 변경된 리소스에 한해서만 전체 콘텐츠가 반환되므로 네트워크 대역폭 낭비를 크게 줄일 수 있습니다.

<u>비동기 캐시 갱신</u> : 사용자가 기한 만료된 콘텐츠를 요청하기 전 다음과 같이 미리 최신 콘텐츠를 받아두는 방법이 있습니다.

```
Cache-constrol: max-age=600, stale-while-revalidate=30
```

위에 Cache-Control 지시자는 600초 동안은 캐시에 저장된 리소스를 서비스 받고 이후 30초는 만료되었지만 여전히 캐시되어 있는 리소스를 서비스 받습니다.

그리고 캐시는 그동안 서버와 통신해 새로운 콘텐츠를 비동기적으로 받아오게 합니다.



<u>절대 캐시 하면 안되게</u> 클라이언트에게 확고하게 알려줄 때 유용하게 사용할 수 있습니다.

```
Cache-constrol: no-cache, no-store, must-revalidate
```



## 2. 캐시 최적화 방안

캐시를 사용하면 사용자가 웹 페이지를 요청하고 로딩할 때 서버의 처리 시간을 줄여주고 캐시 서버와 원본 서버 구간에서 발생하는 RTT도 줄여줍니다. 따라서 최종 사용자의 경험도 향상시킬 수 있습니다. 캐시를 잘 활용하면 프론트엔드 성능을 크게 향상시킬 수 있습니다.

**캐시 효율화를 위한 3원칙**

1. 최대한 많이 캐시하라
2. 최대한 오래 캐시하라
3. 최대한 가까이 캐시하라



**1) 캐시 가능한 콘텐츠 구분하기**

먼저는 웹 페이지의 어떤 콘텐츠를 캐시할 수 있는지, 혹은 캐시하면 안되는지 바로 알아야 합니다. 그리고 캐시할 수 있는 리소스들을 최대한 찾아내 캐시해야합니다.

웹 사이트를 구성하는 콘텐츠는 크게 정적인 콘텐츠와 동적인 콘텐츠로 분류할 수 있습니다.

**정적 콘텐츠** 란 URL을 호출할 때마다 변함없이 같은 응답을 주는 콘텐츠입니다. 대표적으로 이미지, CSS, 자바스크립트 등이 정적 콘텐츠에 속합니다.

**동적 콘텐츠** 란 사용자가 요청할 때마다 서버에 의해 다시 생성, 응답되는 콘텐츠로 서버에서는 HTTP 요청과 함께 입력 시간을 포함한 다양한 변숫값에 따라 콘텐츠를 동적으로 생성하여 응답합니다. AJAX를 사용한 XHR 요청, 사용자가 로그인했을 때 만들어지는 개인화된 웹 페이지들도 동적 콘텐츠라 할 수 있습니다.



**캐시하기 어려운 콘텐츠**

- 개인화된 콘텐츠 : 접속하는 사용자의 정보에 따라 달라지는 콘텐츠로 원본 서버에서 가공되는 콘텐츠를 의미합니다.
- API 호출이나 Ajax 요청에 대한 콘텐츠 : 이러한 요청들은 동적 정보를 원본 서버에 전달해 결괏값을 받습니다. 인증이나 결제 등 서버의 작업이 필요하거나 시간에 따라 빠르게 변하는 정보를 받을 때 사용되므로 캐시에 적합하지 않습니다. 그러나 제품 카탈로그를 내려받거나 스케줄을 조회하는 등 입력값이 동일할 때 결괏값이 동일한 콘텐츠도 많습니다. 이러한 정보들은 캐시할 수 있는 콘텐츠이므로 별도로 분류해야 합니다.
- Beacon 전달 또는 쿠키 설정을 위한 호출 : 간혹 사용자 정보를 수집하거나 브라우저에 쿠키를 설정하기 위해 아주 작은 이미지를 호출하는 경우가 있습니다. 이러한 요청에 대한 응답이 캐시에 저장되면 원본 서버에 정보를 보내거나 받을 수 없으므로 캐시되면 안됩니다.



아래 그림은 WebPageTest(https://www.webpagetest.org/) 라는 사이트를 이용하여 네이버의 메인페이지에 대한 요청과 바이트에 대한 구성요소를 그래프와 표로 나타낸 것입니다.

그림을 보며 동적 콘텐츠를 고려해 캐시할 수 있는지 판단하는데에 참고할 수 있습니다.

![navercontent](https://user-images.githubusercontent.com/66556683/146311818-8984819e-2291-400b-8638-2c8990335d22.png)



**2) 올바른 캐시 정책 설정하기**

캐시 정책을 세우는 것은 캐시할 콘텐츠들의 성격을 파악하고 그룹화하는 것과 같습니다.

1. 먼저 캐시할 수 있는 콘텐츠인지 판단합니다.

   캐시할 수 없는 콘텐츠에는 Cache-Control: no-store 를 붙여 캐시되지 않게 설정합니다.

2. 캐시할 수 있는 콘텐츠들은 매번 원본 서버에 변경 사항을 확인해야 하는지 판단합니다.

   변경에 민감한 리소스는 응답 헤더에 Cache-Control: no-cache나 Cache-control: max-age=0을 사용해 설정합니다.

   이때 응답할 리소스가 변경되지 않았다면 전체 리소스가 아닌 304 코드만 응답하면 되므로 네트워크 대역폭 낭비를 방지할 수 있습니다.

3. 캐시할 콘텐츠들의 성격을 판단합니다.

   모든 사용자에게 공통으로 사용할 수 있다면 Cache-Control: public을 개인화된 콘텐츠라면 Cache-Control: private을 사용합니다. private을 설정할 경우 일반적인 웹 캐시 서버에서 해당 콘텐츠를 캐시할 수 없고 오직 개인 브라우저에서만 캐시합니다.

4. 마지막으로 캐시 주기를 설정하고 max-age를 추가합니다.

<img width="937" alt="cache-control" src="https://user-images.githubusercontent.com/66556683/146316904-88bd1c4e-e045-4cff-b656-89bde3562366.png">



**3) 캐시 주기 결정하기**

1. 캐시 주기는 콘텐츠 타입별로 다르게 설정할 수 있습니다. (특별한 이유가 없다면 캐시 주기를 1년 정도로 길게 설정하는 것을 권장합니다.)

   

2. 만약 링크 변경 없이 이미지 내용만 바꿔야 한다면 캐시 무효화 방식으로 해당 이미지만 캐시에 업데이트합니다.

   CSS, 자바스크립트, 폰트 등의 웹 리소스 파일들은 변경이 얼마나 자주 일어나는지에 따라 다르게 설정하되 그 범위 안에서 가능한 길게 설정합니다.

   그러나 스타일 시트나 스크립트처럼 화면 렌더링에 관련된 파일들은 불규칙하게 수시로 수정이나 업데이트가 발생하므로 상대적으로 짧게 설정합니다.

   변경주기가 잦더라도 캐시하지 않는 것보다 짧게라도 캐시 주기를 정해 캐시하는 것이 성능에 유리합니다.

   

3. 모든 정적 파일에 대해 캐시 주기를 길게 설정하고 수동으로 캐시 주기를 관리하는 방법도 있습니다.

   수동으로 캐시 주기를 관리하는 방법에는 2가지 방법이 있습니다.

   

   파일명 뒤에 해시 값을 자동으로 붙여 파일명을 변경하는 방법

   ```
   script.b2cdd33.js
   index.30s4sccs.js
   ```

   하지만 이 방법은 한 폴더 내에 여러 버전의 유사한 파일들이 많이 쌓이므로 파일 공간을 주기적으로 관리해야합니다.

   <img src="https://user-images.githubusercontent.com/66556683/146870832-b3fd97f3-61bb-43f9-a628-9b20c787c336.png" alt="navercache4" style="zoom:150%;" />

   

   파일 요청 시에 쿼리 스트링으로 버전을 지정하는 방법
   
   ```
   script.js?v=202112161616
   index.js?version=1.0
   ```
   
   이 방법은 같은 파일명을 사용하면서 수동으로 콘텐츠도 업데이트할 수 있습니다. 그러므로 필요할 때마다 쿼리 스트링의 버전만 바꿔주면 됩니다.
   
   <img src="https://user-images.githubusercontent.com/66556683/146870960-abcd7a52-9fc4-417b-acc9-add47fea8f29.png" alt="navercache5" style="zoom:150%;" />



고객 반응에 민감한 웹 사이트 관리자들은 충분히 캐시할 수 있는 정적 리소스도 캐시하지 않으려 합니다. 이런 경우에는 Cache-Control: no-store를 설정하기 보다 Cache-Control: no-cache, max-age=0 을 사용하는 것을 권합니다.



**4) 캐시에 적합한 디렉터리 구조 구성하기**

웹 콘텐츠의 구성 요소들을 파악하고 콘텐츠별 캐시 정책을 정의했다면 캐시 친화적 디렉터리 구조를 구성하는 것을 권합니다.

1. 캐시할 수 있는 콘텐츠들을 별도의 폴더에 분류해 관리합니다. 예를 들어 다음과 같은 정적 콘텐츠들을 /static이란 폴더 아래 배치할 수 있습니다.

   이러한 방법으로 캐시 서버를 /static/* 처럼 간소하게 설정할 수 있습니다. 또한 캐시 가능한 콘텐츠들을 누락시키는 실수를 조금이라도 줄일 수 있다.

2. 캐시를 주기별로 나누어 구성합니다. 같은 콘텐츠 타입이라도 여러 가지 특성에 따라 캐시 주기가 다를 수 있습니다.

3. 동일한 파일을 여러 곳에 분산시키지 않아야 합니다. 웹 사이트를 구성하다 보면 상대 경로를 사용하려고 같은 파일을 여러 폴더에 복제하여 사용하는 경우가 있습니다. 이는 원본 소스를 관리하는 데도 문제가 되지만 캐시에도 도움이 되지 않습니다. 대부분의 캐시 서버는 URL을 키 값으로 하여 동작하므로 복제 생성되는 URL 수만큼 캐시에도 복사본이 생성되기 때문입니다. 캐시 서버 역시 제한된 메모리와 디스크 영역으로 동작하므로 필요 없는 객체들로 리소스를 낭비하지 않아야 합니다. 따라서 동일한 파일은 한 폴더에 보관하고 관련 URL을 참조할 수 있도록 합니다.



**5) 캐시 키 올바르게 사용하기**

캐시 키란 캐시 서버가 원본의 복사본을 저장하고 빠르게 조회하기 위해 사용하는 키 값을 말합니다. 일반적으로 웹 캐시는 클라이언트가 요청하는 URL을 캐시 키로 사용합니다.

일반적인 캐시 키 구성

```
호스트/패스?쿼리 스트링
www.example.com/kr/feo/optimization/img.jpg?width=200&height=100
```

1)캐시 오염과 캐시 충돌

원본 서버에 하나의 원본 파일만 존재하는데 캐시에 복사본이 여러 개 존재하는 것을 **캐시 오염(cache pollution)** 이라 합니다.

**캐시 충돌(cache collision)** 이란 요청 URL이 하나인데 브라우저 환경에 따라 서버에서 제공하는 응답이 달라져 결국 최초 요청한 브라우저의 응답만 캐시되는 것을 의미합니다. 이 경우 나머지 브라우저 환경을 사용하는 사용자들은 잘못된 응답을 받습니다.

<img src="https://user-images.githubusercontent.com/66556683/146487556-d34bb74d-c736-4516-8e2e-93f65ccdf9d8.jpg" alt="cache_p" style="zoom:25%;" />

​	**캐시 오염제거** 

​	캐시 오염은 최종 사용자에게 영향을 주지는 않지만 캐시 서버의 효율성에 큰 영향을 미칠 수 있습니다. 또한 캐시가 퍼지된 경우 원본 서버에 예기치 않은 트래픽 부담을 줄 수 있습니다.

1. URL에 붙은 특정 쿼리 스트링 값이 달라지더라도 응답이 항상 같다면 캐시 키에서 쿼리 스트링을 무시하도록 설정해야 합니다. 쿼리 스트링은 서버 부하를 분산시키려고 서버를 선택하는 것이지만 실제 원본 이미지에는 아무런 영향을 미치지 않지만 캐시 서버에서는 두 개의 URL을 다르게 인식하므로 결과적으로 다른 복사본을 가집니다. 대부분의 캐시 서버에는 특정 쿼리 스트링을 무시할 수 있는 설정이 있습니다.

2. 쿼리 스트링의 순서를 동일하게 정렬합니다. 쿼리 스트링 순서가 달라져도 캐시는 이들을 다르게 인식합니다. 쿼리 스트링의 순서가 달라져도 캐시는 이들을 다르게 인식합니다. 따라서 쿼리스트링을 사용할 때는 오름차순이나 내림차순으로 항상 동일하게 순서를 정렬해 호출하도록 설정해야 합니다.

3. Vary 헤더를 바르게 사용해야 합니다. Vary 헤더가 잘못 사용되었을 때 캐시는 같은 페이지의 복사본을 여러 가지 캐시 키로 다르게 저장하기도 합니다. 동일한 요청에도 브라우저 환경에 따라 응답 콘텐츠가 달라지는 경우 Vary 헤더는 이를 캐시 서버에 알려주어 환경별로 다른 콘텐츠를 캐시하도록 합니다. 브라우저 환경과 상관없이 항상 동일한 페이지가 응답되는데도 서버에서 Vary 헤더를 응답에 보내면 캐시 서버는 같은 콘텐츠에 대한 응답을 브라우저별로 여러 개 만들어 저장합니다. 따라서 꼭 필요한 경구가 아니면 Vary 헤더를 사용하지 않거나 Cache-Control: private을 사용해 중간 캐시 서버에는 캐시하지 않도록 하는 것을 권합니다.

**Vary 헤더** : 서버의 응답이 상황에 따라 달라지는 것을 의미합니다. 서버는 Vary 헤더에 특정 HTTP 헤더 정보를 나열하여 그 헤더 값에 따라 다른 응답을 준 다는 것을 캐시 서버에 알립니다.



​	**캐시 충돌 방지**

​	동적 페이지를 캐시할 때 주로 발생합니다. 홈페이지의 첫 화면을 예로 들면 로그인 전과 후의 페이지가 다릅니다. 로그인 전 페이지는 누구에게나 같게 보이지만 	로그인 후에는 개인화되어 사용자마다 일부 다르게 보입니다. 하지만 이 홈페이지에 Cache-Control: max-age= 1day로 캐시했다면 첫 사용자가 이 홈페이제서 	로그인 전 화면을 로딩해 캐시 서버에 캐시하면 이후 사용자들은 로그인 여부와 상관 없이 같은 화면을 보게 됩니다.

​	일반적으로 홈페이지는 로그인 전 후로 같은 URL을 사용하므로 동적 페이지에 대한 특별한 캐시 설정을 하지 않으면 이러한 캐시 충돌 현상이 일어납니다.

​	이 현상을 피할려면 기본적으로 동적 페이지에는 캐시를 적용하지 않아야 합니다. 일부 동적 페이지에는 캐시를 사용하고자 한다면 Cache-Control: private 으로 	사용자 브라우저에만 캐시하여 페이지 로딩 시간을 단축할 수 있습니다.



**6) CDN 사용하기**

캐시 효율화를 위한 3원칙 중 마지막은 사용자에게 가깝게 캐시하라는 것입니다. 우리나라는 초고속 인터넷을 사용하기 때문에 유용하지 않을 수 있습니다. 

그러나 글로벌 사용자를 대상으로 웹 사이트를 운영하고 있거나 운영할 예정이라면 CDN 서비스로 콘텐츠를 사용자 가까이 캐시해 서비스할 것을 권장합니다.

CDN 서비스를 사용하면 세계 여러 지역 데이터 센터들에 리버스 프록시 캐시 서버를 두고 필요한 정적 콘텐츠들을 저장해 놓을 수 있습니다. 또한 사용자가 관련 콘텐츠를 요청할 때 사용자와 가장 가까운 캐시 서버에서 해당 콘텐츠가 서비스되므로 시간 지연 없이 빠르게 웹 페이지를 로딩할 수 있습니다.





## 3. 고급 캐시 전략

캐시 성능을 더욱 향상시키는 부가 기능

**ESI(Edge Side Include)**

인터넷 에지에서 웹 페이지 조각을 동적으로 조합, 조립, 전달할 수 있도록 이에 대한 문법과 용도 등을 정의한 XML 기반 표준 마크업 언어입니다.

예를 들어 HTML안에 로그인 프로필 같은 서버에서 동적으로 만들어 내는 부분들이 존재하기 때문에 많은 웹 개발자들은 첫 HTML을 캐시하지 않습니다. 하지만 동적으로 변하는 부분은 작을 때가 많습니다. 그런데도 이 부분 때문에 전체 HTML 페이지를 캐시할 수 없어 페이지 로딩 속도에 영향을 미칩니다.

| <img src="https://user-images.githubusercontent.com/66556683/146871837-f0661b3b-0141-42fb-a265-dafca205b9a2.png" alt="login" style="zoom:150%;" /> | <img src="https://user-images.githubusercontent.com/66556683/146871840-f627c4ac-efe8-4cd1-8451-0214c440ff92.png" alt="logout" style="zoom:150%;" /> |
| :----------------------------------------------------------: | :----------------------------------------------------------: |



ESI는 이러한 문제를 해결해줍니다. 동적으로 변하는 부분만 따로 떼어 별도로 수행시킨 후 캐시된 나머지 부분과 다시 조합할 수 있게 만들어줍니다.

<img src="https://user-images.githubusercontent.com/66556683/146699679-afee8dd5-8d04-4f0f-bdb3-2e46f60c9a7c.jpg" alt="ESI" style="zoom:25%;" />

ESI를 사용하면 한 페이지 안에 다른 페이지를 포함시킬 수 있을 뿐만 아니라 각 페이지들이 독립 객체로 취급되어 각각 다른 캐시 정책을 사용할 수 있습니다. 또한 HTTP 헤더 정보를 변수로 참조할 수 있고, 조건문을 사용해 이 변숫값에 따라 다른 비즈니스 로직을 적용할 수도 있습니다. 에러 발생 시 이에 따른 예외 처리를 할 수도 있습니다. 무엇보다 ESI는 HTML과 같은 마크업 언어이며 문법이 단순해 쉽게 배우고 빠르게 사용할 수 있는 장점이 있습니다.

ESI 지원 웹캐시

- 오픈 소스 웹캐시 : Varnish, Squid 등
- 기업형 : Oracle, IBM 등
- CDN업체 : Akamai, CloudFlare, Fastly 등

![esi2](https://user-images.githubusercontent.com/66556683/146701364-f205b76f-5582-4783-8966-424c0cf6cb5b.png)

태그

**include** : 현재 페이지의 현재 위치에 포함시키고자 하는 리소스를 명시합니다.



**choose / when / otherwise** : 조건부 로직을 만들 때 사용합니다.

```
<esi:choose> 
    <esi:when test="$(HTTP_COOKIE{그룹})=='고급'"> 
        <esi:include src="http://www.example.com/advanced.html"/> 
    < /esi:when> 
    <esi:when test="$(HTTP_COOKIE{그룹})=='기본 사용자'"> 
        <esi:include src="http://www.example.com/basic.html"/> 
    </esi:when> 
    <esi:otherwise> 
        <esi:include src="http://www.example.com/new_user.html"/> 
    </esi:otherwise> 
</esi:choose>
```



**try / attempt / except** : Try - catch 와 유사하게 예외 처리 기능을 제공합니다.

```
<esi:try> 
    <esi:attempt>
        <esi:comment text="광고 포함"/> 
        <esi:include src="http://www.example.com/ad1.html"/> 
    </esi:attempt>
    <esi:except> 
        <esi:comment text="대신 HTML을 작성하세요."/> 
        <a href=www.akamai.com>www.example.com</a>
    </esi:except> 
</esi:try>
```

 

**remove** : remove 태그 안의 내용은 ESI 처리기가 제거하고 넘어가 최종 HTML에는 보이지 않습니다. 만약 ESI 처리기가 동작하지 않으면 이 태그 안의 내용이 브라우저에 나타납니다. 그러므로 사용자가 캐시 서버를 거치지 않고 해당 HTML을 응답 받았을 때 민감한 내용이 보일 수 있습니다.

```
<esi:include src="http://www.example.com/ad.html"/> 
<esi:remove> 
  <a href="http://www.example.com">www.example.com</a>
</esi:remove>
```



**ESI 사용 경우**

1. 도입부의 예시와 같이 페이지 내에 일부 동적인 부분이 존재할 때 이 부분만 별도 페이지로 만들어 본래 페이지에 동적으로 삽입할 수 있습니다. 이 기능은 Ajax를 사용한 동적 페이지 로딩과 기능적 측면에서 비슷하지만 동작 방식에 많은 차이가 있습니다. Ajax 방식은 브라우저가 첫 HTML을 다운로드한 후 Ajax 스크립트를 통해 동적 리소스를 가져오기 위해 다시 한번 서버를 호출해야 합니다. 그러나 ESI는 첫 HTML을 다운로드 하는 시점에 캐시 서버에서 실행되어 동적 리소스를 서버에서 불러오기 때문에 Ajax에 비해 한 번에 RTT를 절약할 수 있습니다.

   단 ESI는 서버를 주기적으로 호출할 수 없기 때문에 주기적 업데이트가 필요한 경우, 동적 콘텐츠 생성에 너무 많은 시간이 소요되거나 응답이 없는 경우, 과도한 연산이 필요한 페이지일 경우에는 적합하지 않습니다.

2. 서로 다른 성격의 콘텐츠를 각각의 캐시 정책을 사용해 캐시하고자 할 때 유용합니다.

   | <img src="https://user-images.githubusercontent.com/66556683/146705758-6af6ea36-6f0c-47a3-900c-2533b5ecea96.jpg" alt="esi3" style="zoom: 150%;" /> | <img src="https://user-images.githubusercontent.com/66556683/146705761-aa821973-2438-4691-a166-67fe2344902c.jpg" alt="esi4" style="zoom: 150%;" /> |
   | :----------------------------------------------------------: | :----------------------------------------------------------: |

3. 사용자 등급에 따라 콘텐츠를 제한하고자 할 때 유용합니다. 사용자 등급을 나타내는 쿠키를 추가하고 그 값에 따라 별도 페이지를 가져오도록 ESI를 작성합니다. 이때 choose / when / otherwise 태그들을 이용해 로직을 작성할 수 있습니다.

   <img src="https://user-images.githubusercontent.com/66556683/146710615-c0f6d007-70ba-4122-9db0-23b0bc847656.jpg" alt="esi5" style="zoom:25%;" />



4. 웹 애플리케이션 개발에 협업이 필요할 때 유용합니다. 공통으로 사용할 스타일 시트나 자바스크립트만 미리 협의하면 개발팀들은 맡은 페이지만 독립적으로 개발 및 유지 보수하고 ESI를 사용해 최종 조립하면 됩니다.



**HTML5 로컬 스토리지**

HTML5 웹 스토리지의 가장 중요한 역할은 쿠키를 대체하는 것입니다. 데이터 용량 제한 5MB로서 쿠키 대비 훨씬 많은 사용자 데이터를 저장할 수도 있습니다.

웹 스토리지는 Key/Value 형식으로 저장되어 편리하게 사용할 수 있습니다.

```javascript
/* 웹 스토리지 저장 */
localStorage.setItem("Key","Value");

/* 웹 스토리지 데이터 조회 */
localStorage.getItem("Key");
```



### Tip

웹 캐싱을 슈퍼마켓에서 우유를 사는 과정에 빗대어 설명 : https://rinae.dev/posts/web-caching-explained-by-buying-milk-kr
