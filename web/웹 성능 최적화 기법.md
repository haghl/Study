# 웹 성능 최적화 기법  

## HTTP 요청 수 줄이기

## 웹 성능과 웹 최적화란?  

### 1. 웹 성능이란?

웹 성능이란 웹 사이트의 기능이나 내용을 의미하는 것이 아니라. 콘텐츠가 신속하게 전달되어 사용자가 원하는 서비스를  빠르게 전달받을 수 있도록 하는 시스템들의 성능을 의미합니다.  

즉 웹 성능은  브라우저 주소창에 도메인 주소를 입력하여 해당 사이트로 접속하고 웹 페이지가 로딩되어 내용을 볼 수 있을 때까지 걸린 시간, 웹 로딩 시간을 말합니다.

### 2. 웹 최적화란?

웹 최적화란 최고의 웹 성능을 구현하기 위해 최고의 조건을 만드는 다양한 노력을 의미합니다.

구글에 따르면 로딩 시간이 1~3초에서 느려지면 이탈률이 32% 증가하며 설상가상으로 좋지 않은 로딩 시간은 SEO 순위에 영향을 미칩니다. 페이지 로딩 시간이 지연되면 페이지 조회수가 11% 감소할 수 있으며 이는 Google에 귀하의 페이지가 가치를 제공하지 않는다는 것을 의미합니다.



## 목차

### 1. HTTP의 발전

### 2. HTTP 요청 수 줄이기



## 1. HTTP의 발전

##### TCP, UDP

TCP : 신뢰성을 위해 3-way handshake 방식으로 작동한다.

<img src="https://user-images.githubusercontent.com/66556683/142372518-c1b7c7fa-d141-4baa-8ffc-6d54e4d53244.png" alt="TCP" style="margin:0; zoom: 80%" />  

UDP : 신뢰성보다는 데이터를 일방적으로 보내기만 함.

<img src="https://user-images.githubusercontent.com/66556683/142372647-68a7a752-7806-42b5-9714-09b675a00bc9.png" alt="UDP" style="margin: 0;zoom:150%;" />  

차이점

TCP는 신뢰성은 높으나 전송속도가 UDP에 비해 떨어진다.

반대로 UDP는 신뢰성은 떨어지나 전송속도가 빠르다.



##### HTTP/0.9

초기 HTTP에는 버전 정보가 없었으나 이후 구분을 위해 0.9버전이라고 불리게 됨.

요청은 단일 라인으로 구성되며 가능한 메서드로 GET이 유일했다.

```
GET /mypage.html
```

```
<HTML>
A very simple HTML page
</HTML>
```



##### HTTP/1.0

HTTP/0.9 버전의 제한성을 조금 더 확장해 주었고 헤더가 생겨서 버전을 알려주고 응답에는 상태코드와 또 Content-Type이라는 헤더 덕분에 HTML파일 외에도 다양한 문서들을 전송할 수 있게 되었다.

<img src="https://user-images.githubusercontent.com/66556683/142368090-dc32908f-7e64-4f7c-8a05-0a88bed36a55.png" alt="http1 0" style="margin:0;" />

하지만 HTTP/1.0버전까지 Connection 하나당 응답과 요청 하나만 처리가 가능했음.

그래서 매번 요청이 생길 때 마다 성능의 저하가 일어났고 그로인해 서버의 부하 비용도 상승하게 됨.



##### HTTP/1.1

HTTP 첫 번째 공식 표준 버전이다.

**Persistent Connection** 방식 도입 지정한 timeout동안 커넥션을 닫지 않는 방식.

<img src="https://user-images.githubusercontent.com/66556683/142378114-470d9767-0e6e-4655-87e7-bb5244d3c5ac.png" alt="http1 1" style="margin:0; zoom:150%;" />

하지만 첫 번째 요청에 대한 응답이 있기 전까지 다음 요청에 지연이 발생을 하는 문제가 생김.

**Pipelining** : 하나의 커넥션에서 응답을 기다리지 않고 순차적인 여러 요청을 연속적으로 보내 그 순서에 맞춰 응답을 받는 방식으로 지연 시간을 줄이는 방법.

| <img src="https://user-images.githubusercontent.com/66556683/142380004-27a363f2-1180-492b-bc73-645b04390918.png" alt="pipelining" style="zoom:70%" /> | <img src="https://user-images.githubusercontent.com/66556683/142517727-038b86d7-7aec-432d-9143-66b9a9d020db.png" alt="HOL" style="zoom: 100%" /> |
| :----------------------------------------------------------: | :----------------------------------------------------------: |

파이프라이닝도 **HOL(Head Of Line Blocking) **이 발생 첫번째 요청의 응답시간이 길어지면 다음 요청의 응답도 지연되는 문제가 발생.

또한 연속된 요청시 헤더의 값이 중복되어 쓸데없는 비용 발생하게 됨.



##### HTTP/2

2015년 등장함 HTTP/2 버전의 큰 목표는 클라이언트와 서버가 콘텐츠를 주고 받는 시간을 줄이고, 서버 응답이 느린 콘텐츠가 다른 정상적인 콘텐츠의 전달을 방해하지 않도록 하는 것입니다.

이를 위해 기존 text 방식의 프로토콜을 **bonary frame(이진 프레임)** 방식으로 바꾸어 프로토콜이 더욱 유연해지고 가벼워지게 만듦.

<img src="https://user-images.githubusercontent.com/66556683/142551215-359a4859-838b-4df1-818a-0aabb276dc10.png" alt="header2" style="margin:0; zoom:70%;" />



- **프레임(Frame)** : HTTP/2 통신상 제일 작은 정보 단위이며 헤더나 데이터 중 하나입니다.

- **메시지(Message)** : HTTP/1.1 마찬가지로 요청 혹은 응답 단위이며 다수의 프레임으로 이루어져 있습니다.

- **스트림(Stream)** : 클라이언트와 서버 사이 맺어진 연결을 통하여 양방향으로 주고받는 하나 혹은 복수의 메시지 입니다.

  

  <img src="https://user-images.githubusercontent.com/66556683/142552096-fca3bd35-e9f2-4bb9-a566-331b43a0284c.png" alt="stream" style="zoom:70%;" />



**멀티플렉싱(Multiplexing)** : 하나의 TCP 연결상에서 다수의 클라이언트 요청과 서버의 응답이 비동기 방식으로 이루어지는 기술.

=> 멀티 플렉싱으로 인해 **HOL(Head Of Line Blocking)** 이 해결됨.

  <img src="https://user-images.githubusercontent.com/66556683/142552183-f9c66b31-b495-46fb-a8b2-cdffe19df915.png" alt="stream2" style="zoom:150%;" />



**HPACK : 헤더 압축(Header Compression)**

클라이언트와 서버 사이에 가상 테이블을 만들어서 동일하고 중복되는 헤더 값들을 테이블에 저장하고 인덱스만 전달하고 중복되지 않은 데이터들은

허프만 알고리즘 방식으로 인코딩 하여 압축하는 방식.

=> 헤더의 크기가 약 85% 줄어들어 페이지 로드 시간이 감소.

| <img src="https://user-images.githubusercontent.com/66556683/142521266-5667a366-5dfd-4dee-81f5-0dc84b6244ad.png" alt="header" style="margin:0;zoom:30%;"/> | <img alt="pressing" src="https://user-images.githubusercontent.com/66556683/142565340-743e0972-08a4-4808-ac23-2e65426dab8c.png"  style="margin:0;" /> |
| ------------------------------------------------------------ | :----------------------------------------------------------: |



**서버 푸시(Server Push)** : 클라이언트가 특정 콘텐츠를 요청하면 서버는 이후 추가될 요청을 미리 예상하고 요청 없이도 응답하는 기능

<img src="https://user-images.githubusercontent.com/66556683/142573902-8e624f9a-c216-48f3-8ba9-7a35d6657d32.png" alt="push" style="zoom:60%;" />

##### HTTP/3

구글에서 QUIC를 기반으로 고안해낸 프로토콜로 최신 버전의 HTTP이다.

HTTP/3은 TCP HOL 문제만 개선한 것이 아닌 HTTP/2의 모든 기능을 계승하여 UDP의 빠른 성능, QUIC의 효율성, TLS 1.3의 보안성까지 모든 장점을 가집니다.

**QUIC(Quick UDP Internet Connections)** : TCP, UDP 와 같은 전송 계층의 프로토콜로 구글에서 2013년에 공개했다. 

QUIC는 UDP를 채택하여 TCP의 성능을 개선하려는 기술이며 전달 속도 향상과 더불어 클라이언트와 서버의 연결 수를 최소화하고 대역폭을 예상해 패킷 혼잡을 피하는 것이 QUIC 의 주요 특징이다.

QUIC는 이전에 클라이언트가 한 번이라도 접속했던 서버라면, 별도의 정보 교환없이 바로 데이터를 보내는 **Zero RTT(Round Trip Time : 요청 후에 응답이 돌아오기까지의 시간)**기술을 도입했다. 아직 실험 단계지만 완전히 상용화가 된다면 HTTP/3 기술 중에 가장 획기적인 기술이 될 것이다.

현재 구글 관련 제품 대부분의 기본 프로토콜로 사용된다.



## 2. HTTP 요청 수 줄이기

웹 페이지에 접속 시에 HTTP는 순차적으로 콘텐츠를 다운하여 로딩하게 됩니다. 

![httpdown](https://user-images.githubusercontent.com/66556683/142817288-11cd1679-ce3e-4be0-828d-4fd1da4228d2.png)

웹 페이지에서 요청하는 콘텐츠가 많을 수록 웹 성능이 저하됩니다. 반대로 이미지, 영상 같은 콘텐츠가 적은 페이지 일수록 더욱 빠르게 로딩이 완료됩니다.

그러므로 웹 성능을 더 빠르게 하기 위해서는 HTTP의 요청 수를 줄여야 합니다.

하지만 현실적으로 웹 성능을 위해 나타낼 콘텐츠를 줄이는 것이 현실적으로 적절한 방법은 아닙니다. 페이지에 나타나는 콘텐츠는 동일하게 유지하며 HTTP 요청 수를 줄이는 법을 찾아야 합니다.



#### 1) 콘텐츠 파일 크기 줄이기

성능을 위해 파일을 줄여도 파일 자체의 크기가 크다면 웹 성능의 부정적인 영향을 준다. 그러므로 파일 내용은 변하지 않고 파일 크기를 줄일 수 있도록 해야합니다.

- **스크립트 파일 압축 전달**

  웹 서버가 지원하는 방식으로 스크립트 형태 콘텐츠를 압축해 클라이언트에게 더 작은 크기를 내려주고, 이를 다운로드한 클라이언트가 압축을 해제하는 것 입니다. 클라이언트와 웹 서버간에 서로가 지원하는 다양한 압축 방식중 하나를 정하여 Accept-Encoding, Content-Encoding 헤더를 사용하여 압축 방식의 정보를 교환합니다.

  

  아래의 이미지를 보면 클라이언트는 Accept-Encoding 헤더에 압축 알고리즘을 지정할 수 있고 서버는 요청에  Accept-Encoding 헤더를 보고 그에 맞는 압축 알고리즘으로 데이터를 압축하여 Content-Encoding 헤더를 통해 클라이언트에게 해당 파일이 어떤 압축 알고리즘으로 압축되었는지 알려준다. 클라이언트는 Content-Encoding 헤더를 보고 그에 맞게 압축을 해제한다.

  
  
  <img src="https://user-images.githubusercontent.com/66556683/142791420-754eeb08-a188-40d2-b965-62b706ba3b78.png" alt="gzip" style="zoom:30%;" />
  
  

​		**gzip** : UNIX 운영체제에서 일반적으로 사용하는 LZ77 파일 압축 라이브러리를 사용합니다. 32비트 CRC로 정상 압축 여부를 검사합니다.

​		**deflate** : zlib라는 파일 압축 라이브러리를 사용합니다. RFC 1951에 정의된 압축 방식입니다.

​		**sdch(Shared Dictionary Compression over HTTP)** : 구글이 개발한 HTTP 상의 압축 방식이며 주로 크롬 브라우저에서 사용합니다.



- **스크립트 파일 최소화**

  HTML, 자바스크립트, CSS 같이 코딩된 스크립트 파일에 포함된 주석문, 공백 , 개행 문자 등 실제 로직에 아무런 영향을 주지 않는 부분을 제거하여 전반적인 파일 크기를 줄이는 방식이다.

  최소화 하는 방법으로는 라이브러리, 코딩 툴에 있는 확장자, 사이트(minifier) 등 다양한 방법으로 최소화를 할 수 있다.
  
  ```css
  /* 최소화 전 */
  h1 {
      color: red;
  }
  
  /* 최소화 후 */
  h1{color:red}
  ```
  
  가장 효과적인 방법은 스크립트 파일 최소화로 불필요한 부분을 제거하여 파일을 경량화 하고 위의 스크립트 파일 압축 전달 방식을 둘 다 사용하는 것 입니다.
  
  하지만 해당 사이트의 로직을 변경하거나 기존에 발견치 못한 버그를 디버깅 하는 등 개발자의 작업이 필요한 경우 최소화된 파일로는 해당 작업이 어려울 수 있으므로 개발 서버와 운영 서버를 분리하여 원본 파일은 개발 서버에 두고 운영 서버에는 최소화한 파일을 쓰는 방식을 많이 이용합니다.



- **이미지 파일 압축**

  이미지 파일은 웹 사이트에서 가장 많은 용량을 차지하는 콘텐츠입니다.

  이미지 파일에는 해당 파일의 정보를 메타 데이터에 포함해 저장합니다. 메타 데이터는 사람의 눈에 실제 이미지로써는 보이지 않으므로 불필요한 부분을 제거하면 크기를 상당히 줄일 수 있습니다. 이것을 이미지 파일 압축이라 합니다.



#### 2) 스크립트 파일 병합

소프트웨어 공학에서는 모듈화 하여 개발하는 것을 제안하는데 아이러니하게도 정복과 분할 모듈화는 HTTP의 요청 수를 증가시키므로 웹 성능에 부정적인 영향을 미칩니다.

예를 들어 서버가 파일 1개를 요청하고 응답하는데 1초가 걸린다고 가정합니다. 그럴 경우 100개의 파일을 응답하는 데 100초, 1000개의 파일을 응답하는 데 1000초의 시간이 걸리게 됩니다.

거기에 수많은 사용자가 웹 사이트를 이용할 경우, 응답을 제때 하지 못해 네트워크 병목현상이 일어날 수 있습니다.

따라서 모듈화된 여러 파일들을 기능별로 하나로 합치고 이 파일을 브러우저가 실행하여 동일한 결과를 얻으면 파일 병합으로 HTTP의 요청 수를 줄일 수 있습니다.



개발자들은 스크립트 파일 병합을 쉽고 간편하게 도와주는 툴인 **번들러** 를 사용하여 병합을 하게 됩니다.

번들러란 여러개의 파일을 하나의 파일로 묶어주는 역할을 한다고 말할 수 있습니다. 번들러는 대표적으로 **Webpack, Parcel, Rollup** 가 있습니다. 번들러는 프로젝트 과정에서 설치하여 사용하면 됩니다.

- **Webpack** : 많은 서드파티를 필요로 하는  복잡한 어플리케이션을 만들 때 주로 사용된다.(제일 각광 받고 있음)
- **Parcel** : 복잡한 설정을 피하고 비교적 간단한 어플리케이션을 만들 때 주로 사용된다.
- **Rollup** : 최소한의 서드파티로 라이브러리를 만들 경우 주로 사용된다.



- **빌드**

빌드란 개발자가 만든 소스코드 파일을 실행가능한 소프트웨어 산출물로 만드는 일련의 과정을 말합니다.

최근에 들어 프론트엔드 개발자들은 앵귤러, 리액트, 뷰등의 자바스크립트 프레임워크를 이용하여 웹 개발을 합니다. 이러한 툴 들은 npm run build라는 명령어를 입력할 시에 build 파일이 생성됩니다. 그 안에 있는 파일들은 자동으로 스크립트 파일 병합과 스크립트 파일 최소화가 되어 있습니다.

![merge](https://user-images.githubusercontent.com/66556683/142979531-b10bf662-448a-467a-8a92-427b00a62f76.png)



#### 3) 인라인 이미지

CSS안에 해시 정보를 통해 웹 페이지에 이미지를 파일을 삽입하는 방법입니다.

HTML 파일의 바이트 크기가 소폭 커진다. 하지만 이미지 파일을 따로 호출하던 방식과 비교하였을 때보다 전체 로딩 시간이 단축됩니다.



#### 4) CSS 스프라이트

여러 개의 이미지를 하나의 이미지 파일로 결합해 필요한 이미지가 위치하는 픽셀 좌표 정보를 사용하는 방식입니다.

보통은 버튼, 아이콘 등 작은 이미지를 사용할 때 유용합니다.



**스프라이트 이미지기법을 도와주는 사이트**

- https://spritegen.website-performance.org/ (이미지 소스를 이용하여 스프라이트 이미지로 만들어주는 사이트)
- http://www.spritecow.com/ (스프라이트 이미지의 위치를 소스로 알려주는 사이트)

| <img src="https://user-images.githubusercontent.com/66556683/142829284-ee56d990-e530-480b-b595-f1944215ebb8.png" alt="naver" style="zoom:40%;" /> | <img src="https://user-images.githubusercontent.com/66556683/142829374-cb32c345-2423-4829-9884-14dceeedf311.png" alt="google" style="zoom:120%;" /> |
| :----------------------------------------------------------: | :----------------------------------------------------------: |



```css
.sprite {
    width: 100px;
    height: 100px;
    background: url('img/sprite_img.png') no-repeat 0 0 /cover;
}

.sprite.sprite_1 {
   background-position: 0 -100px;
}

.sprite.sprite_2 {
   background-position: -100px -100px;
}
```





